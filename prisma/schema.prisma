// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// Role enums for organization and club memberships
enum MembershipRole {
  ORGANIZATION_ADMIN
  MEMBER
}

enum ClubMembershipRole {
  CLUB_ADMIN
  MEMBER
}

// Sport types supported by the platform
enum SportType {
  PADEL
  TENNIS
  PICKLEBALL
  SQUASH
  BADMINTON
}

model User {
  id              String           @id @default(uuid())
  name            String?
  email           String           @unique
  emailVerified   DateTime?
  image           String?
  password        String?
  isRoot          Boolean          @default(false)
  blocked         Boolean          @default(false)
  lastLoginAt     DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @default(now()) @updatedAt
  accounts        Account[]
  sessions        Session[]
  coaches         Coach[]
  bookings        Booking[]
  memberships     Membership[]
  clubMemberships ClubMembership[]
  createdOrganizations Organization[] @relation("OrganizationCreator")
  createdClubs    Club[]           @relation("ClubCreator")
}

model Organization {
  id          String       @id @default(uuid())
  name        String
  slug        String       @unique
  contactEmail String?
  contactPhone String?
  website     String?
  address     String?
  metadata    String?      @db.Text // JSON string for additional metadata
  supportedSports SportType[] @default([PADEL]) // Sports supported by this organization
  createdById String
  createdBy   User         @relation("OrganizationCreator", fields: [createdById], references: [id])
  archivedAt  DateTime?    // Soft-delete timestamp
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @default(now()) @updatedAt
  memberships Membership[]
  clubs       Club[]
}

model Membership {
  id             String         @id @default(uuid())
  userId         String
  organizationId String
  role           MembershipRole
  isPrimaryOwner Boolean        @default(false)
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization   Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @default(now()) @updatedAt

  @@unique([userId, organizationId])
  @@index([userId])
  @@index([organizationId])
  @@index([userId, organizationId])
}

model ClubMembership {
  id        String             @id @default(uuid())
  userId    String
  clubId    String
  role      ClubMembershipRole
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  club      Club               @relation(fields: [clubId], references: [id], onDelete: Cascade)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @default(now()) @updatedAt

  @@unique([userId, clubId])
  @@index([userId])
  @@index([clubId])
  @@index([userId, clubId])
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Club {
  id               String           @id @default(uuid())
  name             String
  slug             String?          @unique
  organizationId   String?
  organization     Organization?    @relation(fields: [organizationId], references: [id])
  createdById      String?
  createdBy        User?            @relation("ClubCreator", fields: [createdById], references: [id])
  shortDescription String?
  longDescription  String?          @db.Text
  location         String
  city             String?
  country          String?
  latitude         Float?
  longitude        Float?
  phone            String?
  email            String?
  website          String?
  socialLinks      String?          @db.Text  // JSON string for social links
  contactInfo      String?
  openingHours     String?
  logo             String?
  heroImage        String?
  defaultCurrency  String?          @default("USD")
  timezone         String?          @default("UTC")
  isPublic         Boolean          @default(true)
  status           String           @default("active") // "active", "draft", "suspended"
  tags             String?          // JSON array of tags
  supportedSports  SportType[]      @default([PADEL]) // Sports supported by this club
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @default(now()) @updatedAt
  courts           Court[]
  coaches          Coach[]
  pricingRules     PricingRule[]
  gallery          ClubGallery[]
  businessHours    ClubBusinessHours[]
  specialHours     ClubSpecialHours[]
  clubMemberships  ClubMembership[]

  @@index([organizationId])
}

model ClubGallery {
  id        String   @id @default(uuid())
  clubId    String
  imageUrl  String
  imageKey  String?
  altText   String?
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  club      Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@index([clubId])
}

model ClubBusinessHours {
  id        String   @id @default(uuid())
  clubId    String
  dayOfWeek Int      // 0=Sunday, 1=Monday, ..., 6=Saturday
  openTime  String?  // "HH:mm" format, null if closed
  closeTime String?  // "HH:mm" format, null if closed
  isClosed  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  club      Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([clubId, dayOfWeek])
  @@index([clubId])
}

model ClubSpecialHours {
  id        String   @id @default(uuid())
  clubId    String
  date      DateTime @db.Date
  openTime  String?  // "HH:mm" format, null if closed
  closeTime String?  // "HH:mm" format, null if closed
  isClosed  Boolean  @default(false)
  reason    String?  // e.g., "Holiday", "Maintenance"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  club      Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([clubId, date])
  @@index([clubId])
}

model Court {
  id                String        @id @default(uuid())
  clubId            String
  name              String
  slug              String?       @unique
  type              String?
  surface           String?
  indoor            Boolean       @default(false)
  sportType         SportType     @default(PADEL) // Type of sport for this court
  isActive          Boolean       @default(true)
  defaultPriceCents Int           @default(0)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  club            Club             @relation(fields: [clubId], references: [id])
  bookings        Booking[]
  pricingRules    PricingRule[]
  courtPriceRules CourtPriceRule[]
}

model CourtPriceRule {
  id         String    @id @default(uuid())
  courtId    String
  dayOfWeek  Int?      // 0=Sunday .. 6=Saturday OR null = applies to all days
  date       DateTime? @db.Date // optional exact date override (mutually exclusive with dayOfWeek)
  startTime  String    // "09:00" format
  endTime    String    // "12:00" format
  priceCents Int
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  court Court @relation(fields: [courtId], references: [id], onDelete: Cascade)

  @@index([courtId])
}

model Coach {
  id                   String                    @id @default(uuid())
  user                 User                      @relation(fields: [userId], references: [id])
  userId               String
  club                 Club?                     @relation(fields: [clubId], references: [id])
  clubId               String?
  bio                  String?
  phone                String?
  availabilities       CoachAvailability[]
  weeklyAvailabilities CoachWeeklyAvailability[]
  timeOffs             CoachTimeOff[]
  createdAt            DateTime                  @default(now())
  bookings             Booking[]
}

model CoachAvailability {
  id        String   @id @default(uuid())
  coach     Coach    @relation(fields: [coachId], references: [id])
  coachId   String
  start     DateTime
  end       DateTime
  createdAt DateTime @default(now())
}

model CoachWeeklyAvailability {
  id        String   @id @default(uuid())
  coach     Coach    @relation(fields: [coachId], references: [id], onDelete: Cascade)
  coachId   String
  dayOfWeek Int      // 0=Sunday, 1=Monday, ..., 6=Saturday
  startTime String   // "HH:mm" format
  endTime   String   // "HH:mm" format
  note      String?  // Optional label or note
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([coachId])
  @@index([coachId, dayOfWeek])
}

model CoachTimeOff {
  id        String    @id @default(uuid())
  coach     Coach     @relation(fields: [coachId], references: [id], onDelete: Cascade)
  coachId   String
  date      DateTime  @db.Date
  startTime String?   // "HH:mm" format, optional for full-day off
  endTime   String?   // "HH:mm" format, optional for full-day off
  reason    String?   // Optional comment
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([coachId])
  @@index([coachId, date])
}

model Booking {
  id            String    @id @default(uuid())
  court         Court     @relation(fields: [courtId], references: [id])
  courtId       String
  user          User      @relation(fields: [userId], references: [id])
  userId        String
  coach         Coach?    @relation(fields: [coachId], references: [id])
  coachId       String?
  start         DateTime
  end           DateTime
  price         Int
  sportType     SportType @default(PADEL) // Type of sport for this booking
  status        String    @default("pending") // Legacy field for backward compatibility: "pending", "paid", "cancelled", etc.
  bookingStatus String    @default("Pending") // Booking status: "Active", "Cancelled", "Completed", "No-show", "Pending"
  paymentStatus String    @default("Unpaid") // Payment status: "Paid", "Unpaid", "Refunded", "PartiallyRefunded", "PaymentPending"
  paymentId     String?
  createdAt     DateTime  @default(now())
  payments      Payment[]
}

model Payment {
  id        String   @id @default(uuid())
  booking   Booking  @relation(fields: [bookingId], references: [id])
  bookingId String
  provider  String
  status    String
  amount    Int
  createdAt DateTime @default(now())
}

model PricingRule {
  id        String    @id @default(uuid())
  club      Club      @relation(fields: [clubId], references: [id])
  clubId    String
  court     Court?    @relation(fields: [courtId], references: [id])
  courtId   String?
  startTime Int
  endTime   Int
  price     Int
  sportType SportType @default(PADEL) // Type of sport for this pricing rule
  createdAt DateTime  @default(now())
}

model TrainingRequest {
  id        String   @id @default(uuid())
  trainerId String
  playerId  String
  clubId    String
  courtId   String?  // Reserved court for the training session
  bookingId String?  // Associated booking ID
  date      DateTime @db.Date
  time      String   // "HH:MM" format
  comment   String?
  status    String   @default("pending") // "pending", "confirmed", "rejected", "cancelled"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trainerId])
  @@index([playerId])
  @@index([clubId])
  @@index([courtId])
  @@index([bookingId])
}

model AdminNotification {
  id                String   @id @default(uuid())
  type              String   // "REQUESTED", "ACCEPTED", "DECLINED", "CANCELED"
  playerId          String
  coachId           String
  trainingRequestId String?
  bookingId         String?
  sessionDate       DateTime? @db.Date  // Optional metadata: date of session
  sessionTime       String?             // Optional metadata: time of session
  courtInfo         String?             // Optional metadata: court info
  read              Boolean  @default(false)
  createdAt         DateTime @default(now())

  @@index([read])
  @@index([createdAt])
}

// Audit Log for tracking admin actions
model AuditLog {
  id          String   @id @default(uuid())
  actorId     String
  action      String   // e.g., "org.update", "org.archive", "org.delete", "org.reassign_owner"
  targetType  String   // e.g., "organization", "club", "user"
  targetId    String   // ID of the affected entity
  detail      String?  @db.Text // JSON string with additional context
  createdAt   DateTime @default(now())

  @@index([actorId])
  @@index([targetType, targetId])
  @@index([createdAt])
}
